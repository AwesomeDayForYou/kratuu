<!DOCTYPE html>
<html lang="th">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>กระดานสนทนาเรียลไทม์</title>
    <!-- โหลด Tailwind CSS -->
    <script src="https://cdn.tailwindcss.com"></script>
    <!-- Font Awesome for Trash Icon -->
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.0.0-beta3/css/all.min.css" crossorigin="anonymous" referrerpolicy="no-referrer" />
    <style>
        @import url('https://fonts.googleapis.com/css2?family=Inter:wght@100..900&family=Noto+Sans+Thai:wght@100..900&display=swap');
        body {
            font-family: 'Noto Sans Thai', 'Inter', sans-serif;
            background-color: #f7f7f7;
        }
        /* Style for the fixed modal overlay */
        #modal-container {
            transition: opacity 0.3s ease-in-out;
        }
        /* Ensure content respects whitespace for formatting */
        .whitespace-pre-wrap {
            white-space: pre-wrap;
        }
    </style>
</head>
<body class="p-4 sm:p-8">

    <div id="app" class="max-w-4xl mx-auto">
        <!-- Header -->
        <header class="text-center mb-8 p-4 bg-white shadow-lg rounded-xl">
            <h1 class="text-3xl font-bold text-gray-800">กระดานสนทนา</h1>
            <p class="text-gray-500 mt-1">พื้นที่แบ่งปันความคิดเห็นแบบเรียลไทม์</p>
            <div id="auth-status" class="mt-4 p-2 text-sm bg-indigo-100 text-indigo-800 rounded-lg">
                กำลังเชื่อมต่อ...
            </div>
            <!-- Admin Login Button -->
            <button id="admin-login-btn" class="bg-red-600 hover:bg-red-700 text-white font-bold py-2 px-6 rounded-lg transition duration-300 shadow-lg text-base mt-4">
                เข้าสู่ระบบผู้ดูแล (Admin)
            </button>
        </header>

        <!-- New Thread Form (สร้างกระทู้ใหม่) -->
        <div class="bg-white p-6 shadow-lg rounded-xl mb-8">
            <h2 class="text-xl font-semibold mb-4 text-gray-700">สร้างกระทู้ใหม่</h2>
            <form id="new-thread-form">
                <input type="text" id="thread-title" placeholder="ชื่อหัวข้อกระทู้" required
                       class="w-full p-3 mb-3 border border-gray-300 rounded-lg focus:ring-indigo-500 focus:border-indigo-500 transition duration-150"
                       maxlength="100">
                <textarea id="thread-content" placeholder="เนื้อหาของคุณ..." required
                          class="w-full p-3 mb-4 border border-gray-300 rounded-lg focus:ring-indigo-500 focus:border-indigo-500 h-24 resize-none transition duration-150"></textarea>
                <button type="submit" id="submit-button"
                        class="w-full bg-indigo-600 hover:bg-indigo-700 text-white font-bold py-3 px-4 rounded-lg transition duration-300 shadow-md disabled:bg-indigo-400"
                        disabled>
                    โพสต์กระทู้
                </button>
            </form>
            
            <!-- Custom Modal Container -->
            <div id="modal-container" class="fixed inset-0 z-50 flex items-center justify-center hidden opacity-0">
                <div class="absolute inset-0 bg-gray-900 opacity-75" onclick="closeModal()"></div>
                
                <!-- General Message Modal (Default) -->
                <div id="message-modal" class="bg-white p-6 rounded-lg shadow-2xl z-10 max-w-sm w-full transform transition-all scale-100 hidden">
                    <h3 class="text-xl font-bold mb-3 text-red-600">ข้อผิดพลาด</h3>
                    <p id="modal-text" class="text-gray-700 mb-4"></p>
                    <button onclick="closeModal()" class="w-full bg-red-600 hover:bg-red-700 text-white font-bold py-2 rounded-lg transition duration-200">
                        ปิด
                    </button>
                </div>

                <!-- Admin Login Modal -->
                <div id="admin-modal" class="bg-white p-6 rounded-lg shadow-2xl z-10 max-w-sm w-full transform transition-all scale-100 hidden">
                    <h3 class="text-xl font-bold mb-3 text-red-600">เข้าสู่ระบบผู้ดูแล</h3>
                    <form id="admin-login-form">
                        <input type="text" id="admin-username" placeholder="ชื่อผู้ใช้" required
                            class="w-full p-3 mb-3 border border-gray-300 rounded-lg focus:ring-red-500 focus:border-red-500 transition duration-150">
                        <input type="password" id="admin-password" placeholder="รหัสผ่าน" required
                            class="w-full p-3 mb-4 border border-gray-300 rounded-lg focus:ring-red-500 focus:border-red-500 transition duration-150">
                        <p class="text-xs text-red-500 mb-4">
                            *** คำเตือน: Notfound404 eiei ***
                        </p>
                        <button type="submit" id="admin-login-submit"
                            class="w-full bg-red-600 hover:bg-red-700 text-white font-bold py-3 rounded-lg transition duration-200">
                            เข้าสู่ระบบ
                        </button>
                    </form>
                    <button onclick="closeModal()" class="w-full mt-2 bg-gray-300 hover:bg-gray-400 text-gray-800 font-bold py-2 rounded-lg transition duration-200">
                        ยกเลิก
                    </button>
                </div>
                
                <!-- Nickname Setup Modal -->
                <div id="nickname-modal" class="bg-white p-6 rounded-lg shadow-2xl z-10 max-w-sm w-full transform transition-all scale-100 hidden">
                    <h3 class="text-xl font-bold mb-3 text-indigo-600">ยินดีต้อนรับ! ตั้งชื่อผู้ใช้</h3>
                    <p class="text-gray-700 mb-4">
                        กรุณาตั้งชื่อผู้ใช้ของคุณ. ชื่อนี้จะถูกใช้ในการแสดงความคิดเห็น
                        <span class="font-bold text-red-500">(ไม่สามารถแก้ไขได้ภายหลัง)</span>
                    </p>
                    <form id="nickname-form">
                        <input type="text" id="display-name" placeholder="ชื่อผู้ใช้ (1-20 ตัวอักษร)" required maxlength="20"
                            class="w-full p-3 mb-4 border border-indigo-300 rounded-lg focus:ring-indigo-500 focus:border-indigo-500 transition duration-150">
                        <button type="submit" id="nickname-submit"
                            class="w-full bg-indigo-600 hover:bg-indigo-700 text-white font-bold py-3 rounded-lg transition duration-200">
                            บันทึกชื่อผู้ใช้
                        </button>
                    </form>
                </div>

            </div>
        </div>

        <!-- Thread List (รายการกระทู้) -->
        <div class="mb-4">
            <h2 class="text-2xl font-bold text-gray-800">กระทู้ทั้งหมด</h2>
            <p class="text-sm text-gray-500">อัปเดตแบบเรียลไทม์</p>
        </div>

        <div id="threads-container" class="space-y-4">
            <!-- Threads will be inserted here by JavaScript -->
            <div id="loading-indicator" class="text-center p-8 text-gray-500">
                กำลังโหลดกระทู้...
            </div>
        </div>
    </div>

    <!-- Firebase SDKs and Application Logic -->
    <script type="module">
        import { initializeApp } from "https://www.gstatic.com/firebasejs/11.6.1/firebase-app.js";
        import { getAuth, signInAnonymously, signInWithCustomToken, onAuthStateChanged } from "https://www.gstatic.com/firebasejs/11.6.1/firebase-auth.js";
        import { getFirestore, collection, query, onSnapshot, addDoc, serverTimestamp, setLogLevel, deleteDoc, doc, getDoc, setDoc } from "https://www.gstatic.com/firebasejs/11.6.1/firebase-firestore.js";

        // Global variables provided by the environment
        const appId = typeof __app_id !== 'undefined' ? __app_id : 'default-app-id';

        // ----------------------------------------------------------------------
        // --- START: CONFIGURATION FOR SELF-HOSTING (*** DO NOT CHANGE ***) ---
        // Firebase Configuration (Using the values provided by the user)
        const myFirebaseConfig = {
            apiKey: "AIzaSyBpPa3wswWOVTh1_6KoSPBM6xL7BIBmXwI", 
            authDomain: "coffee-spark-ai-barista-bbcaa.firebaseapp.com",
            projectId: "coffee-spark-ai-barista-bbcaa",
            storageBucket: "coffee-spark-ai-barista-bbcaa.firebasestorage.app",
            messagingSenderId: "908525996884",
            appId: "1:908525996884:web:b37d55cc5318c21eafd6c1"
        };
        // --- END: CONFIGURATION FOR SELF-HOSTING ---
        // ----------------------------------------------------------------------

        // Use config from Canvas environment (if available) or use myFirebaseConfig (for self-hosting)
        const firebaseConfig = typeof __firebase_config !== 'undefined' ? JSON.parse(__firebase_config) : myFirebaseConfig;
        
        // Use Custom Auth Token from Canvas (if available) otherwise use Anonymous sign-in
        const initialAuthToken = typeof __initial_auth_token !== 'undefined' ? __initial_auth_token : null;

        // --- ADMIN CREDENTIALS (Local Simulation - Credentials kept local in code) ---
        // NOTE: These credentials are for front-end simulation only and do not bypass Firestore rules.
        const ADMIN_USERNAME = 'Jocey';
        const ADMIN_PASSWORD = '1234';
        let isAdmin = false; // Admin status
        // -------------------------------------------------

        // --- BACKEND ENDPOINT FOR CASCADING DELETE (Hypothetical) ---
        // In a real application, this would be the URL of a deployed Cloud Function or API endpoint.
        const ADMIN_DELETE_ENDPOINT = 'https://your-cloud-function-url.cloudfunctions.net/deleteThread';
        // -----------------------------------------------------------

        let app;
        let db;
        let auth;
        let userId = null;
        let isAuthReady = false;
        let currentUserName = null; // Current user's display name (Nickname)
        const userNicknames = new Map(); // Cache for all fetched nicknames

        const threadsContainer = document.getElementById('threads-container');
        const authStatusElement = document.getElementById('auth-status');
        const form = document.getElementById('new-thread-form');
        const submitButton = document.getElementById('submit-button');
        const loadingIndicator = document.getElementById('loading-indicator');
        const adminLoginButton = document.getElementById('admin-login-btn');
        const adminLoginForm = document.getElementById('admin-login-form');
        const modalContainer = document.getElementById('modal-container');
        const nicknameForm = document.getElementById('nickname-form');


        // --- Utility Functions ---

        /** Displays a custom modal message. (General Alert) */
        function showModal(title, text) {
            const modalText = document.getElementById('modal-text');
            const modalTitle = document.querySelector('#message-modal h3');
            
            modalTitle.textContent = title;
            modalText.textContent = text;
            
            // Hide other modals and show message modal
            document.getElementById('admin-modal').classList.add('hidden');
            document.getElementById('nickname-modal').classList.add('hidden');
            document.getElementById('message-modal').classList.remove('hidden');
            
            // Show modal container with transition
            modalContainer.classList.remove('hidden');
            setTimeout(() => {
                modalContainer.style.opacity = '1';
            }, 10);
        }

        /** Opens the Admin Login Modal */
        function showAdminLoginModal() {
            document.getElementById('admin-modal').classList.remove('hidden');
            document.getElementById('message-modal').classList.add('hidden');
            document.getElementById('nickname-modal').classList.add('hidden');

            modalContainer.classList.remove('hidden');
            setTimeout(() => {
                modalContainer.style.opacity = '1';
                document.getElementById('admin-username').focus();
            }, 10);
        }
        
        /** Opens the Nickname Setup Modal */
        function promptForNickname() {
            document.getElementById('nickname-modal').classList.remove('hidden');
            document.getElementById('message-modal').classList.add('hidden');
            document.getElementById('admin-modal').classList.add('hidden');

            modalContainer.classList.remove('hidden');
            // Prevent closing the modal until nickname is set
            document.querySelector('#modal-container > .absolute').onclick = null; 

            setTimeout(() => {
                modalContainer.style.opacity = '1';
                document.getElementById('display-name').focus();
            }, 10);
        }

        /** Closes the custom modal. (Handles cleanup) */
        window.closeModal = function() {
            // Hide all specific modals
            document.getElementById('message-modal').classList.add('hidden');
            document.getElementById('admin-modal').classList.add('hidden');
            document.getElementById('nickname-modal').classList.add('hidden');

            // Restore default overlay click behavior
            document.querySelector('#modal-container > .absolute').onclick = () => closeModal(); 

            // Hide main container
            modalContainer.style.opacity = '0';
            setTimeout(() => {
                modalContainer.classList.add('hidden');
            }, 300);
        }
        
        /** Formats a Firestore Timestamp into a readable date string. */
        function formatTimestamp(timestamp) {
            if (!timestamp || !timestamp.toDate) return 'ไม่ทราบเวลา';
            const date = timestamp.toDate();
            // Using 'th-TH' for Thai locale formatting
            return date.toLocaleTimeString('th-TH', { 
                hour: '2-digit', 
                minute: '2-digit', 
                day: '2-digit', 
                month: '2-digit', 
                year: 'numeric' 
            });
        }
        
        /** Updates the Auth Status UI */
        function updateAuthStatusUI() {
            let adminTag = '';
            let statusText = 'กำลังเชื่อมต่อ...';
            
            if (userId) {
                const adminColor = isAdmin ? 'bg-red-500 text-white' : 'bg-indigo-100 text-indigo-800';
                adminTag = isAdmin 
                    ? `<span class="text-xs bg-red-700 text-white font-medium px-2 py-0.5 rounded-full mr-2">ADMIN MODE</span>`
                    : '';
                
                const displayNameText = currentUserName ? currentUserName : `User ID: ${userId}`;
                
                statusText = `✅ เชื่อมต่อแล้ว. ${adminTag}ชื่อผู้ใช้: <span class="font-bold">${displayNameText}</span>`;
                authStatusElement.className = `mt-4 p-2 text-sm ${adminColor} rounded-lg`;
            } else {
                statusText = '⛔ ไม่ได้เข้าสู่ระบบ';
                authStatusElement.className = `mt-4 p-2 text-sm bg-indigo-100 text-indigo-800 rounded-lg`;
            }

            authStatusElement.innerHTML = statusText;
            // Disable posting until nickname is set and user is authenticated
            submitButton.disabled = !userId || !currentUserName; 
            
            // Re-render threads to enable/disable comment posting buttons based on currentUserName
            // Note: A full re-render is expensive, but necessary here to update dynamic buttons inside threads.
            listenForThreads(); 
        }


        // --- Firebase Initialization and Authentication ---

        async function initializeFirebase() {
            try {
                // setLogLevel('debug'); // Uncomment this line to see detailed Firebase logs in console
                app = initializeApp(firebaseConfig);
                db = getFirestore(app);
                auth = getAuth(app);

                // 1. Set up Auth Listener to handle user state changes
                onAuthStateChanged(auth, async (user) => {
                    if (user) {
                        userId = user.uid;
                        // Fetch nickname or prompt for setup
                        await setupUserAndNickname(user.uid); 
                    } else {
                        userId = null;
                        currentUserName = null;
                        isAdmin = false;
                    }
                    isAuthReady = true;
                    updateAuthStatusUI();
                    listenForThreads();
                });

                // 2. Sign in using the custom token (for Canvas) or anonymously (for self-hosting)
                if (initialAuthToken) {
                    await signInWithCustomToken(auth, initialAuthToken);
                } else {
                    await signInAnonymously(auth); 
                }
            } catch (error) {
                console.error("Firebase initialization or sign-in failed:", error);
                showModal('ข้อผิดพลาดในการเชื่อมต่อ', `ไม่สามารถเชื่อมต่อ Firebase ได้: ${error.message}`);
                authStatusElement.textContent = '❌ การเชื่อมต่อล้มเหลว';
            }
        }
        
        // --- NICKNAME/PROFILE LOGIC ---

        function getUserProfileRef(uid) {
            // Public collection to store user display names so everyone can read them
            return doc(db, `artifacts/${appId}/public/data/user_profiles/${uid}`);
        }
        
        /** Fetches nickname from Firestore and updates the cache. */
        async function fetchNickname(uid) {
            if (userNicknames.has(uid)) return userNicknames.get(uid);

            try {
                const docSnap = await getDoc(getUserProfileRef(uid));
                if (docSnap.exists() && docSnap.data().displayName) {
                    const name = docSnap.data().displayName;
                    userNicknames.set(uid, name);
                    return name;
                }
            } catch (error) {
                console.error(`Error fetching nickname for ${uid}:`, error);
            }
            // Fallback: Use truncated ID if name doesn't exist or failed to fetch
            const fallbackName = `User-${uid.substring(0, 4)}...`;
            userNicknames.set(uid, fallbackName); 
            return fallbackName;
        }

        /** Gets the display name from the cache or a fallback. */
        function getDisplayName(uid) {
            return userNicknames.get(uid) || `User-${uid.substring(0, 4)}...`;
        }

        /** Checks if the current user has a nickname set, otherwise prompts for one. */
        async function setupUserAndNickname(uid) {
            const profileSnap = await getDoc(getUserProfileRef(uid));
            
            if (profileSnap.exists() && profileSnap.data().displayName) {
                currentUserName = profileSnap.data().displayName;
                userNicknames.set(uid, currentUserName);
            } else {
                // If the user is authenticated but has no nickname, prompt them
                currentUserName = null; // Ensure this is null until set
                promptForNickname();
            }
        }

        /** Handles nickname form submission (can only set once). */
        async function handleNicknameSet(event) {
            event.preventDefault();
            const displayNameInput = document.getElementById('display-name');
            const newDisplayName = displayNameInput.value.trim();

            if (!newDisplayName || newDisplayName.length > 20) {
                showModal('ข้อผิดพลาด', 'กรุณาตั้งชื่อผู้ใช้ 1-20 ตัวอักษร');
                return;
            }
            if (!userId) {
                showModal('ข้อผิดพลาด', 'การตรวจสอบสิทธิ์ยังไม่เสร็จสมบูรณ์');
                return;
            }

            const submitBtn = document.getElementById('nickname-submit');
            submitBtn.disabled = true;
            submitBtn.textContent = 'กำลังบันทึก...';

            try {
                // Check again if the name exists to enforce 'set once' rule
                const profileSnap = await getDoc(getUserProfileRef(userId));
                if (profileSnap.exists() && profileSnap.data().displayName) {
                    throw new Error('ชื่อผู้ใช้ถูกตั้งค่าแล้ว');
                }
                
                await setDoc(getUserProfileRef(userId), {
                    displayName: newDisplayName,
                    createdAt: serverTimestamp(),
                }, { merge: false }); // merge: false ensures we overwrite/set initial data

                currentUserName = newDisplayName;
                userNicknames.set(userId, newDisplayName);
                closeModal(); // Close the nickname modal
                updateAuthStatusUI();
                showModal('บันทึกสำเร็จ', `ตั้งชื่อผู้ใช้ "${newDisplayName}" เรียบร้อยแล้ว. คุณสามารถเริ่มโพสต์ได้`);
                
            } catch (error) {
                console.error("Error setting nickname: ", error);
                showModal('ตั้งชื่อผู้ใช้ไม่สำเร็จ', `เกิดข้อผิดพลาด: ${error.message}`);
            } finally {
                submitBtn.textContent = 'บันทึกชื่อผู้ใช้';
                submitBtn.disabled = false;
            }
        }

        // --- END: NICKNAME/PROFILE LOGIC ---

        // --- Admin Login Logic ---
        
        function handleAdminLogin(event) {
            event.preventDefault();
            const username = document.getElementById('admin-username').value.trim();
            const password = document.getElementById('admin-password').value.trim();
            
            if (username === ADMIN_USERNAME && password === ADMIN_PASSWORD) {
                isAdmin = true;
                closeModal();
                showModal('เข้าสู่ระบบสำเร็จ', `คุณเข้าสู่ระบบในฐานะผู้ดูแล (Admin) ด้วย User ID: ${userId} เรียบร้อยแล้ว`);
                updateAuthStatusUI();
                // Re-render threads to show delete buttons
                listenForThreads(); 
            } else {
                showModal('เข้าสู่ระบบไม่สำเร็จ', 'ชื่อผู้ใช้หรือรหัสผ่านไม่ถูกต้อง');
            }
        }
        
        // --- Firestore Utility References ---

        function getThreadsCollectionRef() {
            return collection(db, `artifacts/${appId}/public/data/threads`);
        }
        
        function getThreadDocRef(threadId) {
            return doc(db, `artifacts/${appId}/public/data/threads/${threadId}`);
        }

        function getCommentsCollectionRef(threadId) {
            return collection(db, `artifacts/${appId}/public/data/threads/${threadId}/comments`);
        }
        
        function getCommentDocRef(threadId, commentId) {
            return doc(db, `artifacts/${appId}/public/data/threads/${threadId}/comments/${commentId}`);
        }

        // --- DELETE FUNCTIONS (UPDATED) ---
        
        /** * Calls a backend service to recursively delete a thread and its subcollection. 
         * NOTE: This is a placeholder call and will only succeed if a service running 
         * the Admin SDK (like a Cloud Function) is deployed at ADMIN_DELETE_ENDPOINT.
         */
        async function callAdminDeleteThread(threadId) {
            if (!isAdmin) {
                showModal('สิทธิ์ไม่เพียงพอ', 'คุณไม่มีสิทธิ์ในการลบกระทู้นี้ กรุณาเข้าสู่ระบบในฐานะ Admin');
                return;
            }

            // In a real environment, you'd secure this API call, e.g., by passing the user's ID token.
            const token = await auth.currentUser?.getIdToken();

            showModal('กำลังดำเนินการ', 'กำลังลบกระทู้และความคิดเห็นทั้งหมด (ติดต่อ Admin Service...)');

            try {
                // *** SIMULATION OF ADMIN SERVICE FAILURE ***
                // Since there is no actual running backend service, this will fail.
                // We show an informative error for the user to understand the requirement.
                throw new Error("Recursive deletion requires a deployed Admin SDK service (e.g., Cloud Function). The local simulation cannot perform this.");
                
                /* // *** REAL API CALL (if ADMIN_DELETE_ENDPOINT were deployed) ***
                const response = await fetch(ADMIN_DELETE_ENDPOINT, {
                    method: 'POST',
                    headers: {
                        'Content-Type': 'application/json',
                        'Authorization': `Bearer ${token}` // Pass token for verification
                    },
                    body: JSON.stringify({ appId: appId, threadId: threadId })
                });

                if (!response.ok) {
                    const errorData = await response.json();
                    throw new Error(errorData.message || 'Server failed to delete thread recursively.');
                }
                
                showModal('ลบสำเร็จ', `ลบกระทู้ ID: ${threadId} และความคิดเห็นทั้งหมดเรียบร้อยแล้ว`);
                */

            } catch (error) {
                console.error("Error calling Admin Delete Endpoint:", error);
                
                // If the simulated call fails, use a fallback client-side delete, 
                // but warn the admin that comments might be left behind (orphaned data).
                if (error.message.includes("Cloud Function") || error.message.includes("cannot perform this")) {
                    await deleteThreadFallback(threadId); // Fallback to client-side delete
                } else {
                    // Show actual API error
                    showModal('ลบไม่สำเร็จ (Admin Service)', `ไม่สามารถเรียกใช้ Admin Service ได้: ${error.message}`);
                }
            }
        }
        
        /** * Fallback client-side delete for when the Admin Service is not available. 
         * WARNS the admin about orphaned subcollections (comments).
         */
        async function deleteThreadFallback(threadId) {
            if (!isAdmin) return; // Should already be checked

            try {
                let retryCount = 0;
                const maxRetries = 5;
                let delay = 1000;

                while (retryCount < maxRetries) {
                    try {
                        await deleteDoc(getThreadDocRef(threadId));
                        showModal('ลบสำเร็จ (Client-Side)', `⚠️ ลบกระทู้ ID: ${threadId} แล้ว. 
                            (เนื่องจากไม่มี Admin Service, ความคิดเห็นย่อยอาจยังคงอยู่)`);
                        break;
                    } catch (error) {
                        retryCount++;
                        if (retryCount >= maxRetries) {
                            throw error;
                        }
                        console.warn(`Firestore thread delete failed, retrying in ${delay / 1000}s... Attempt ${retryCount}`);
                        await new Promise(resolve => setTimeout(resolve, delay));
                        delay *= 2; 
                    }
                }
            } catch (error) {
                console.error("Error deleting thread (fallback):", error);
                showModal('ลบไม่สำเร็จ (Fallback)', `ไม่สามารถลบกระทู้: ${error.message}`);
            }
        }

        /** Deletes a single comment (always possible from client). */
        async function deleteComment(threadId, commentId) {
            if (!isAdmin) {
                showModal('สิทธิ์ไม่เพียงพอ', 'คุณไม่มีสิทธิ์ในการลบความคิดเห็นนี้ กรุณาเข้าสู่ระบบในฐานะ Admin');
                return;
            }

            try {
                let retryCount = 0;
                const maxRetries = 5;
                let delay = 1000;

                while (retryCount < maxRetries) {
                    try {
                        await deleteDoc(getCommentDocRef(threadId, commentId));
                        break;
                    } catch (error) {
                        retryCount++;
                        if (retryCount >= maxRetries) {
                            throw error;
                        }
                        console.warn(`Firestore comment delete failed, retrying in ${delay / 1000}s... Attempt ${retryCount}`);
                        await new Promise(resolve => setTimeout(resolve, delay));
                        delay *= 2; 
                    }
                }
            } catch (error) {
                console.error("Error deleting comment:", error);
                showModal('ลบไม่สำเร็จ', `ไม่สามารถลบความคิดเห็น: ${error.message}`);
            }
        }
        
        // Expose wrappers to global scope for use in onclick attributes
        window.deleteThreadWrapper = callAdminDeleteThread; // New wrapper uses the admin call function
        window.deleteCommentWrapper = deleteComment;

        // --- END: DELETE FUNCTIONS ---


        /** Creates a DOM element for a single comment. */
        function createCommentElement(comment, threadId) {
            const commentEl = document.createElement('div');
            commentEl.className = 'border-l-2 border-gray-200 pl-4 py-2 my-2 bg-gray-50 rounded-lg';
            const isCreator = comment.userId === userId;
            
            // Get Display Name
            const commenterName = getDisplayName(comment.userId);

            const creatorTag = isCreator 
                ? `<span class="text-xs bg-green-100 text-green-600 font-medium px-2 py-0.5 rounded-full mr-1">คุณ</span>`
                : '';
                
            const deleteButton = isAdmin
                ? `<button onclick="deleteCommentWrapper('${threadId}', '${comment.id}')" 
                            class="ml-2 text-red-500 hover:text-red-700 transition duration-150 p-1 rounded-full hover:bg-red-200" title="ลบความคิดเห็นนี้">
                    <i class="fas fa-trash-alt h-4 w-4 inline-block align-middle"></i>
                </button>`
                : '';

            commentEl.innerHTML = `
                <p class="text-gray-700 mb-1 whitespace-pre-wrap text-sm">${comment.content}</p>
                <div class="flex justify-between items-center text-xs text-gray-400 mt-1">
                    <span class="flex items-center">
                        ${creatorTag} ผู้ใช้: <span class="font-bold text-gray-800">${commenterName}</span>
                        ${deleteButton}
                    </span>
                    <span>${formatTimestamp(comment.createdAt)}</span>
                </div>
            `;
            return commentEl;
        }

        /** Listens for real-time updates on the comments subcollection for a given thread. */
        function listenForComments(threadId, commentsListEl, toggleButton) {
            if (!db) return;

            const commentsQuery = query(getCommentsCollectionRef(threadId));

            // Unsubscribe listener if it exists before attaching a new one (important for re-renders)
            // This is handled by onSnapshot returning an unsubscribe function, which is not tracked globally here, 
            // but is acceptable since thread elements are recreated/replaced upon major data change.
            
            const unsubscribe = onSnapshot(commentsQuery, async (snapshot) => {
                commentsListEl.innerHTML = ''; 

                const comments = [];
                const userIdsToFetch = new Set();
                snapshot.forEach(doc => {
                    const data = doc.data();
                    comments.push({ id: doc.id, ...data });
                    userIdsToFetch.add(data.userId);
                });

                // Fetch nicknames for all commenters in this thread (updates cache)
                const fetchPromises = Array.from(userIdsToFetch).map(uid => fetchNickname(uid));
                await Promise.all(fetchPromises);


                comments.sort((a, b) => {
                    const timeA = a.createdAt?.toMillis() || 0;
                    const timeB = b.createdAt?.toMillis() || 0;
                    return timeA - timeB; // Sort ascending (oldest first)
                });
                
                if (toggleButton) {
                    toggleButton.textContent = `แสดงความคิดเห็น (${comments.length} รายการ)`;
                }

                if (comments.length === 0) {
                    commentsListEl.innerHTML = '<p class="text-center text-gray-400 py-4 text-sm">ยังไม่มีความคิดเห็น</p>';
                } else {
                    comments.forEach(comment => {
                        commentsListEl.appendChild(createCommentElement(comment, threadId));
                    });
                }

            }, (error) => {
                console.error(`Error listening to comments for thread ${threadId}:`, error);
                if (toggleButton) {
                    toggleButton.textContent = `แสดงความคิดเห็น (โหลดผิดพลาด)`;
                }
            });
            
            return unsubscribe;
        }

        /** Handles form submission to add a new comment. */
        async function addComment(event, threadId) {
            event.preventDefault();
            
            if (!currentUserName) {
                promptForNickname(); // Force nickname setup
                return;
            }

            const form = event.target;
            const contentInput = form.querySelector('textarea[name="content"]');
            const content = contentInput.value.trim();
            const submitBtn = form.querySelector('button[type="submit"]');

            if (!userId) {
                showModal('เข้าสู่ระบบ', 'กรุณารอการตรวจสอบสิทธิ์ก่อนแสดงความคิดเห็น');
                return;
            }
            if (!content) {
                showModal('ข้อมูลไม่ครบถ้วน', 'กรุณากรอกเนื้อหาความคิดเห็น');
                return;
            }

            submitBtn.disabled = true;
            submitBtn.textContent = 'กำลังส่ง...';

            try {
                let retryCount = 0;
                const maxRetries = 5;
                let delay = 1000; // 1 second

                while (retryCount < maxRetries) {
                    try {
                        await addDoc(getCommentsCollectionRef(threadId), {
                            content: content,
                            userId: userId,
                            createdAt: serverTimestamp(),
                        });
                        break; 
                    } catch (error) {
                        retryCount++;
                        if (retryCount >= maxRetries) {
                            throw error;
                        }
                        console.warn(`Firestore comment write failed, retrying in ${delay / 1000}s... Attempt ${retryCount}`);
                        // Exponential backoff
                        await new Promise(resolve => setTimeout(resolve, delay));
                        delay *= 2; 
                    }
                }

                contentInput.value = '';
                
            } catch (error) {
                console.error("Error adding comment: ", error);
                showModal('ส่งความคิดเห็นไม่สำเร็จ', `เกิดข้อผิดพลาดในการแสดงความคิดเห็น: ${error.message}`);
            } finally {
                submitBtn.textContent = 'ส่งความคิดเห็น';
                submitBtn.disabled = false;
            }
        }


        /** Listens for real-time updates on the threads collection. */
        function listenForThreads() {
            if (!isAuthReady || !db) {
                return;
            }

            const threadsQuery = query(getThreadsCollectionRef());

            const unsubscribe = onSnapshot(threadsQuery, async (snapshot) => {
                loadingIndicator.style.display = 'none';
                threadsContainer.innerHTML = '';

                const threads = [];
                const userIdsToFetch = new Set();

                snapshot.forEach(doc => {
                    const data = doc.data();
                    threads.push({ id: doc.id, ...data });
                    userIdsToFetch.add(data.userId);
                });

                // Fetch nicknames for all thread creators (updates cache)
                const fetchPromises = Array.from(userIdsToFetch).map(uid => fetchNickname(uid));
                await Promise.all(fetchPromises);

                threads.sort((a, b) => {
                    const timeA = a.createdAt?.toMillis() || 0;
                    const timeB = b.createdAt?.toMillis() || 0;
                    return timeB - timeA; // Sort descending (newest first)
                });

                if (threads.length === 0) {
                    threadsContainer.innerHTML = '<p class="text-center text-gray-500 p-8 bg-white rounded-xl shadow-lg">ยังไม่มีกระทู้. ลองสร้างกระทู้แรกของคุณสิ!</p>';
                } else {
                    threads.forEach(thread => {
                        threadsContainer.appendChild(createThreadElement(thread));
                    });
                }

            }, (error) => {
                console.error("Error listening to threads:", error);
                showModal('ข้อผิดพลาดในการโหลดข้อมูล', `ไม่สามารถโหลดรายการกระทู้ได้: ${error.message}`);
                loadingIndicator.textContent = 'เกิดข้อผิดพลาดในการโหลดข้อมูล';
            });
            
            return unsubscribe;
        }

        /** Creates a DOM element for a single thread. */
        function createThreadElement(thread) {
            const threadEl = document.createElement('div');
            threadEl.id = `thread-${thread.id}`;
            threadEl.className = 'bg-white p-6 rounded-xl shadow-lg border-l-4 border-indigo-500 hover:shadow-xl transition duration-300';
            
            // Show full content inside the thread element
            const contentDisplay = thread.content; 

            const isCreator = thread.userId === userId;
            
            const creatorName = getDisplayName(thread.userId);

            const creatorTag = isCreator 
                ? `<span class="text-xs bg-indigo-100 text-indigo-600 font-medium px-2 py-0.5 rounded-full">คุณ</span>`
                : '';
            
            // Only Admin can delete a thread
            const deleteThreadButton = isAdmin
                ? `<button onclick="deleteThreadWrapper('${thread.id}')" 
                            class="ml-3 bg-red-500 hover:bg-red-600 text-white font-bold py-1 px-3 rounded-lg text-xs transition duration-150 shadow-md" title="ลบกระทู้และข้อมูลทั้งหมด">
                    ลบกระทู้
                </button>`
                : '';
            
            // Initial HTML structure with Comment Section hidden
            threadEl.innerHTML = `
                <h3 class="text-xl font-bold text-gray-800 mb-2">${thread.title}</h3>
                <p class="text-gray-600 mb-4 whitespace-pre-wrap">${contentDisplay}</p>
                
                <div class="flex justify-between items-center text-sm text-gray-500 border-t pt-3 mt-3">
                    <span class="flex items-center space-x-2">
                        <span>${creatorTag} ผู้ใช้: <span class="font-bold text-gray-800">${creatorName}</span></span>
                        ${deleteThreadButton}
                    </span>
                    <span>โพสต์เมื่อ: ${formatTimestamp(thread.createdAt)}</span>
                </div>
                
                <button id="toggle-comments-${thread.id}" 
                        class="mt-4 text-sm font-medium text-indigo-600 hover:text-indigo-800 transition duration-150 focus:outline-none">
                    แสดงความคิดเห็น (กำลังโหลด...)
                </button>

                <div id="comments-section-${thread.id}" class="mt-4 hidden bg-gray-100 p-4 rounded-lg">
                    <h4 class="text-lg font-semibold text-gray-700 mb-3">ความคิดเห็น:</h4>
                    
                    <!-- Comment List Container -->
                    <div id="comments-list-${thread.id}" class="space-y-3">
                        <!-- Comments will be inserted here -->
                        <p class="text-center text-gray-500 text-sm">กำลังโหลดความคิดเห็น...</p>
                    </div>
                    
                    <!-- New Comment Form -->
                    <form id="add-comment-form-${thread.id}" class="mt-4 pt-4 border-t border-gray-300">
                        <textarea name="content" placeholder="แสดงความคิดเห็นของคุณ..." required
                                  class="w-full p-2 mb-2 border border-gray-300 rounded-lg focus:ring-indigo-500 focus:border-indigo-500 resize-none text-sm" rows="2"></textarea>
                        <button type="submit" 
                                class="w-full bg-indigo-500 hover:bg-indigo-600 text-white font-bold py-2 rounded-lg text-sm transition duration-300 shadow-sm disabled:bg-indigo-400"
                                disabled>
                            ส่งความคิดเห็น
                        </button>
                    </form>
                </div>
            `;

            // --- Post-Render Setup (Comment Logic) ---

            const commentsSection = threadEl.querySelector(`#comments-section-${thread.id}`);
            const commentsListEl = threadEl.querySelector(`#comments-list-${thread.id}`);
            const toggleButton = threadEl.querySelector(`#toggle-comments-${thread.id}`);
            const commentForm = threadEl.querySelector(`#add-comment-form-${thread.id}`);
            const commentSubmitButton = commentForm.querySelector('button[type="submit"]');

            // 1. Start listener immediately to get the comment count and real-time updates
            listenForComments(thread.id, commentsListEl, toggleButton);

            // 2. Enable comment button if authenticated state is known AND nickname is set
            if (isAuthReady && userId && currentUserName) {
                commentSubmitButton.disabled = false;
            } else {
                 commentSubmitButton.textContent = currentUserName ? 'ส่งความคิดเห็น' : 'กรุณาตั้งชื่อผู้ใช้';
            }

            // 3. Listener for Comment Form submission
            commentForm.addEventListener('submit', (e) => addComment(e, thread.id));

            // 4. Toggle logic
            toggleButton.addEventListener('click', () => {
                const isHidden = commentsSection.classList.contains('hidden');
                
                if (isHidden) {
                    commentsSection.classList.remove('hidden');
                    toggleButton.textContent = 'ซ่อนความคิดเห็น';
                } else {
                    commentsSection.classList.add('hidden');
                    const currentCountText = toggleButton.textContent;
                    // Replace 'ซ่อนความคิดเห็น' with 'แสดงความคิดเห็น (X รายการ)' text, preserving the count
                    toggleButton.textContent = currentCountText.replace('ซ่อนความคิดเห็น', 'แสดงความคิดเห็น');
                }
            });

            return threadEl;
        }

        /** Handles form submission to create a new thread. */
        async function createThread(event) {
            event.preventDefault();

            if (!userId) {
                showModal('เข้าสู่ระบบ', 'กรุณารอการตรวจสอบสิทธิ์ก่อนโพสต์');
                return;
            }
            if (!currentUserName) {
                promptForNickname(); // Force nickname setup
                return;
            }

            const title = document.getElementById('thread-title').value.trim();
            const content = document.getElementById('thread-content').value.trim();

            if (!title || !content) {
                showModal('ข้อมูลไม่ครบถ้วน', 'กรุณากรอกทั้งชื่อหัวข้อและเนื้อหา');
                return;
            }

            submitButton.disabled = true;
            submitButton.textContent = 'กำลังโพสต์...';

            try {
                let retryCount = 0;
                const maxRetries = 5;
                let delay = 1000;

                while (retryCount < maxRetries) {
                    try {
                        await addDoc(getThreadsCollectionRef(), {
                            title: title,
                            content: content,
                            userId: userId,
                            createdAt: serverTimestamp(),
                        });
                        break;
                    } catch (error) {
                        retryCount++;
                        if (retryCount >= maxRetries) {
                            throw error;
                        }
                        console.warn(`Firestore write failed, retrying in ${delay / 1000}s... Attempt ${retryCount}`);
                        await new Promise(resolve => setTimeout(resolve, delay));
                        delay *= 2; 
                    }
                }

                document.getElementById('thread-title').value = '';
                document.getElementById('thread-content').value = '';

            } catch (error) {
                console.error("Error adding document: ", error);
                showModal('โพสต์ไม่สำเร็จ', `เกิดข้อผิดพลาดในการโพสต์กระทู้ (อาจเกิดจาก Security Rules ไม่อนุญาต): ${error.message}`);
            } finally {
                submitButton.textContent = 'โพสต์กระทู้';
                // Button is re-enabled by updateAuthStatusUI via onAuthStateChanged or nickname setup success
                // We keep it disabled here to rely on the central auth status logic.
                // submitButton.disabled = false;
            }
        }

        // --- Event Listeners and Initial Load ---
        
        window.onload = initializeFirebase;
        form.addEventListener('submit', createThread);
        
        // Listener for the Admin Login button
        adminLoginButton.addEventListener('click', showAdminLoginModal);
        
        // Listener for the Admin Login form submission
        adminLoginForm.addEventListener('submit', handleAdminLogin);
        
        // Listener for the Nickname form submission
        nicknameForm.addEventListener('submit', handleNicknameSet);

    </script>
</body>
</html>
